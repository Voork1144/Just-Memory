# Just-Memory v1.3 Feature Research: Bi-Temporal Edges & Spreading Activation

> Deep research on advanced features for knowledge graph enhancement

## Executive Summary

This document explores two sophisticated features for Just-Memory v1.3:
1. **Bi-Temporal Edges** - Track both when facts were true (valid time) and when we learned them (transaction time)
2. **Spreading Activation** - Cognitively-inspired retrieval that propagates activation through the graph

---

## 1. Bi-Temporal Edges

### 1.1 Concept Overview

Bi-temporal databases track two independent time dimensions:

| Dimension | Description | Example |
|-----------|-------------|---------|
| **Valid Time (T)** | When a fact is true in the real world | "Eric worked at Company X from 2020-2023" |
| **Transaction Time (T')** | When the fact was recorded in the database | "We learned this on Jan 24, 2026" |

**Why this matters for AI memory:**
- Allows "time travel" queries: "What did we know on date X about topic Y?"
- Enables contradiction detection: "Fact A was valid from T1-T2, but superseded by Fact B at T2"
- Supports retroactive corrections without losing history

### 1.2 Graphiti/Zep Implementation (State of the Art)

From the Zep paper (arxiv.org/abs/2501.13956), their bi-temporal model tracks **4 timestamps per edge**:

```
Edge {
  t_valid: DateTime      // When fact became true
  t_invalid: DateTime    // When fact stopped being true (null = still valid)
  t'_created: DateTime   // When we stored this in the database
  t'_expired: DateTime   // When this record was superseded (null = current)
}
```

**Key insight**: Edge invalidation is NOT deletion. Old edges are marked with `t_invalid` but preserved for historical queries.

### 1.3 Proposed Just-Memory v1.3 Schema

Extend our existing `relations` table:

```sql
CREATE TABLE relations (
  id TEXT PRIMARY KEY,
  from_id TEXT NOT NULL,
  to_id TEXT NOT NULL,
  relation_type TEXT NOT NULL,
  weight REAL DEFAULT 1.0,
  
  -- Bi-temporal fields (NEW)
  valid_from DATETIME,           -- When fact became true (can be past)
  valid_to DATETIME,             -- When fact stopped being true (null = still valid)
  transaction_created DATETIME,  -- When we recorded this (auto: NOW())
  transaction_expired DATETIME,  -- When superseded (null = current record)
  
  -- Metadata
  confidence REAL DEFAULT 1.0,   -- How sure are we? (0.0-1.0)
  source TEXT,                   -- Where did this come from?
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (from_id) REFERENCES memories(id),
  FOREIGN KEY (to_id) REFERENCES memories(id)
);
```

### 1.4 New Query Types Enabled

| Query | SQL Pattern |
|-------|-------------|
| Current facts | `WHERE valid_to IS NULL AND transaction_expired IS NULL` |
| Facts at time T | `WHERE valid_from <= T AND (valid_to IS NULL OR valid_to > T)` |
| What we knew at T' about time T | `WHERE transaction_created <= T' AND (transaction_expired IS NULL OR transaction_expired > T')` |
| Superseded facts | `WHERE transaction_expired IS NOT NULL` |

### 1.5 New Tools for v1.3

```typescript
// memory_relate (enhanced)
memory_relate({
  from_id: string,
  to_id: string,
  relation_type: string,
  weight?: number,
  valid_from?: DateTime,  // NEW: When fact became true
  valid_to?: DateTime,    // NEW: When fact stopped being true
  confidence?: number,    // NEW: How sure are we?
  source?: string         // NEW: Where did this come from?
})

// memory_invalidate (NEW)
memory_invalidate({
  relation_id: string,
  valid_to?: DateTime,    // When the fact stopped being true
  reason?: string         // Why are we invalidating?
})

// memory_at_time (NEW)
memory_at_time({
  query: string,
  as_of_valid: DateTime,       // What was true at this time?
  as_of_transaction?: DateTime // What did we know at this time?
})
```

---

## 2. Spreading Activation

### 2.1 Concept Overview

Spreading activation is a cognitive science model of how human memory retrieval works:

1. A "seed" concept is activated (e.g., searching for "Python")
2. Activation spreads to connected nodes (e.g., "programming", "snake", "Monty Python")
3. Activation decays with distance and is modulated by edge weights
4. Nodes with highest accumulated activation are retrieved

**Key insight from Collins & Loftus (1975)**: This explains "semantic priming" - why thinking about "doctor" makes "nurse" come to mind faster.

### 2.2 Algorithm

From SpreadPy (arxiv.org/pdf/2507.09628):

```python
def spreading_activation(graph, seeds, max_iterations=3, decay=0.85, threshold=0.01):
    """
    Spread activation from seed nodes through the graph.
    
    Args:
        seeds: Dict[node_id, initial_activation]
        decay: How much activation decreases per hop (0.0-1.0)
        threshold: Minimum activation to continue spreading
    """
    activation = dict(seeds)
    
    for iteration in range(max_iterations):
        new_activation = {}
        
        for node, act in activation.items():
            if act < threshold:
                continue
                
            neighbors = graph.get_neighbors(node)
            for neighbor, edge_weight in neighbors:
                spread = act * decay * edge_weight
                new_activation[neighbor] = new_activation.get(neighbor, 0) + spread
        
        # Merge new activations
        for node, act in new_activation.items():
            if node not in seeds:  # Don't re-activate seeds
                activation[node] = activation.get(node, 0) + act
    
    return sorted(activation.items(), key=lambda x: -x[1])
```

### 2.3 Enhancements for AI Memory

From EcphoryRAG (arxiv.org/pdf/2510.08958) and GraphRAG papers:

| Enhancement | Description |
|-------------|-------------|
| **Cue-driven activation** | Use LLM to extract specific cues from query, not just keywords |
| **Edge-type weighting** | Different relation types spread differently (e.g., "causes" > "relates_to") |
| **Semantic similarity** | Combine with embedding similarity for hybrid activation |
| **Personalized PageRank** | Use PPR variant for more targeted spreading |

### 2.4 Proposed Just-Memory Implementation

```typescript
// memory_spread (NEW tool)
memory_spread({
  seeds: Array<{id: string, activation: number}>,  // Starting nodes
  max_depth: number = 2,       // How far to spread
  decay: number = 0.85,        // Activation decay per hop
  threshold: number = 0.01,    // Minimum activation to continue
  relation_weights?: {         // Optional per-type weights
    [type: string]: number     // e.g., {"causes": 1.5, "relates_to": 0.8}
  },
  limit: number = 20           // Max results to return
}) => {
  nodes: Array<{
    id: string,
    content: string,
    activation: number,
    depth: number,
    path: string[]  // How we got here
  }>,
  edges_traversed: number
}
```

### 2.5 Integration with Existing Search

Combine spreading activation with our hybrid search:

```typescript
// Enhanced memory_search
memory_search({
  query: string,
  mode: "hybrid" | "keyword" | "semantic" | "spread",  // NEW mode
  spread_config?: {
    decay: number,
    max_depth: number,
    combine_with_semantic: boolean  // Multiply by cosine similarity
  }
})
```

**Hybrid approach:**
1. Semantic search finds initial seeds (top-k by embedding similarity)
2. Spreading activation expands from seeds
3. Final score = semantic_score * activation_score
4. Re-rank and return top results

---

## 3. Implementation Priority

### Phase 3.1: Bi-Temporal Foundation
1. Extend `relations` table with temporal columns
2. Update `memory_relate` to accept temporal params
3. Add `memory_invalidate` tool
4. Add temporal query filters

### Phase 3.2: Spreading Activation
1. Implement basic spreading algorithm
2. Add `memory_spread` tool
3. Integrate with existing search modes
4. Add relation-type weighting

### Phase 3.3: Advanced Features
1. Point-in-time queries (`memory_at_time`)
2. Contradiction detection
3. Cue extraction for activation
4. Performance optimization (caching, indexing)

---

## 4. Competitive Advantage

| Feature | Graphiti/Zep | MemGPT | Basic Memory | Just-Memory v1.3 |
|---------|--------------|--------|--------------|------------------|
| Bi-temporal tracking | ✅ | ❌ | ❌ | ✅ (planned) |
| Spreading activation | ✅ (PPR) | ❌ | ❌ | ✅ (planned) |
| No external DB required | ❌ (Neo4j) | ✅ | ✅ | ✅ (SQLite) |
| Hybrid search (BM25+vector) | ✅ | ❌ | ❌ | ✅ (existing) |
| Ebbinghaus decay | ❌ | ❌ | ❌ | ✅ (existing) |
| Lightweight/portable | ❌ | ✅ | ✅ | ✅ |

**Just-Memory v1.3 differentiator**: Enterprise-grade temporal knowledge graph features in a lightweight, portable SQLite package with no external dependencies.

---

## 5. References

1. Zep Paper: "A Temporal Knowledge Graph Architecture for Agent Memory" (arxiv.org/abs/2501.13956)
2. Collins & Loftus (1975): "A Spreading-Activation Theory of Semantic Processing"
3. SpreadPy: Python tool for spreading activation (arxiv.org/pdf/2507.09628)
4. EcphoryRAG: Cue-driven retrieval (arxiv.org/pdf/2510.08958)
5. Martin Fowler: "Bitemporal History" (martinfowler.com/articles/bitemporal-history.html)
6. SQL:2011 Temporal Extensions (Wikipedia)

---

## 6. Estimated Effort

| Phase | Features | Effort |
|-------|----------|--------|
| 3.1 | Bi-temporal schema + tools | 4-6 hours |
| 3.2 | Spreading activation | 4-6 hours |
| 3.3 | Advanced features | 6-8 hours |

**Total for v1.3**: ~14-20 hours