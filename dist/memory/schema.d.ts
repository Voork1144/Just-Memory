/**
 * Just-Command Memory Database Schema
 *
 * Implements decisions:
 * - D1: Basic entities v1 (full Knowledge Graph deferred to v2)
 * - D3: Search returns 100-char snippets (implemented at query time)
 * - D4: Soft delete with recovery (deleted_at column)
 * - D5: Store both absolute/relative paths
 * - D10: Memory decay opt-in (decay_enabled flag)
 * - D15: Project isolation via project_id column
 * - D20: SQLite WAL mode + busy_timeout (in sqlite-config.ts)
 */
/**
 * Schema version for migrations
 */
export declare const SCHEMA_VERSION = 1;
/**
 * SQL statements to create the memory database schema
 */
export declare const SCHEMA_SQL = "\n-- Enable foreign keys\nPRAGMA foreign_keys = ON;\n\n-- Schema version tracking\nCREATE TABLE IF NOT EXISTS schema_version (\n  version INTEGER PRIMARY KEY,\n  applied_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- Insert initial version if not exists\nINSERT OR IGNORE INTO schema_version (version) VALUES (1);\n\n-- =============================================================================\n-- MEMORIES TABLE\n-- Core storage for all memories (facts, events, observations, preferences)\n-- =============================================================================\nCREATE TABLE IF NOT EXISTS memories (\n  -- Primary key\n  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),\n  \n  -- Content\n  content TEXT NOT NULL,\n  \n  -- Embedding vector (stored as BLOB, 384 dimensions for all-MiniLM-L6-v2)\n  embedding BLOB,\n  \n  -- Type: 'fact', 'event', 'observation', 'preference', 'note', 'decision'\n  type TEXT NOT NULL DEFAULT 'fact',\n  \n  -- Optional: associate memory with a source (file path, URL, etc.)\n  source TEXT,\n  \n  -- Project isolation (D15)\n  project_id TEXT,\n  \n  -- Tags for categorization (JSON array)\n  tags TEXT DEFAULT '[]',\n  \n  -- Arbitrary metadata (JSON object)\n  metadata TEXT DEFAULT '{}',\n  \n  -- Importance score (0.0 to 1.0, higher = more important)\n  importance REAL NOT NULL DEFAULT 0.5,\n  \n  -- Decay settings (D10: opt-in memory decay)\n  decay_enabled INTEGER NOT NULL DEFAULT 0,\n  last_accessed_at TEXT,\n  access_count INTEGER NOT NULL DEFAULT 0,\n  \n  -- Timestamps\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now')),\n  \n  -- Soft delete (D4)\n  deleted_at TEXT\n);\n\n-- Indexes for memories\nCREATE INDEX IF NOT EXISTS idx_memories_type ON memories(type) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_memories_project ON memories(project_id) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_memories_created ON memories(created_at) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_memories_importance ON memories(importance DESC) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_memories_source ON memories(source) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_memories_deleted ON memories(deleted_at) WHERE deleted_at IS NOT NULL;\n\n-- Full-text search for BM25 ranking\nCREATE VIRTUAL TABLE IF NOT EXISTS memories_fts USING fts5(\n  content,\n  tags,\n  metadata,\n  content='memories',\n  content_rowid='rowid'\n);\n\n-- Triggers to keep FTS in sync\nCREATE TRIGGER IF NOT EXISTS memories_ai AFTER INSERT ON memories BEGIN\n  INSERT INTO memories_fts(rowid, content, tags, metadata) \n  VALUES (NEW.rowid, NEW.content, NEW.tags, NEW.metadata);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS memories_ad AFTER DELETE ON memories BEGIN\n  INSERT INTO memories_fts(memories_fts, rowid, content, tags, metadata) \n  VALUES ('delete', OLD.rowid, OLD.content, OLD.tags, OLD.metadata);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS memories_au AFTER UPDATE ON memories BEGIN\n  INSERT INTO memories_fts(memories_fts, rowid, content, tags, metadata) \n  VALUES ('delete', OLD.rowid, OLD.content, OLD.tags, OLD.metadata);\n  INSERT INTO memories_fts(rowid, content, tags, metadata) \n  VALUES (NEW.rowid, NEW.content, NEW.tags, NEW.metadata);\nEND;\n\n-- =============================================================================\n-- ENTITIES TABLE (D1: Basic v1)\n-- Named things that can be referenced across memories\n-- =============================================================================\nCREATE TABLE IF NOT EXISTS entities (\n  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),\n  \n  -- Name of the entity (e.g., \"John\", \"ProjectX\", \"React\")\n  name TEXT NOT NULL,\n  \n  -- Type: 'person', 'project', 'technology', 'organization', 'concept', 'place', 'other'\n  type TEXT NOT NULL DEFAULT 'other',\n  \n  -- Description/notes about the entity\n  description TEXT,\n  \n  -- Embedding for semantic search\n  embedding BLOB,\n  \n  -- Project isolation (D15)\n  project_id TEXT,\n  \n  -- Arbitrary metadata (JSON object)\n  metadata TEXT DEFAULT '{}',\n  \n  -- Timestamps\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now')),\n  \n  -- Soft delete (D4)\n  deleted_at TEXT,\n  \n  -- Unique constraint on name within project\n  UNIQUE(name, project_id)\n);\n\n-- Indexes for entities\nCREATE INDEX IF NOT EXISTS idx_entities_name ON entities(name) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_entities_type ON entities(type) WHERE deleted_at IS NULL;\nCREATE INDEX IF NOT EXISTS idx_entities_project ON entities(project_id) WHERE deleted_at IS NULL;\n\n-- =============================================================================\n-- RELATIONS TABLE\n-- Links between memories and/or entities\n-- =============================================================================\nCREATE TABLE IF NOT EXISTS relations (\n  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),\n  \n  -- Source: can be memory or entity ID\n  source_id TEXT NOT NULL,\n  source_type TEXT NOT NULL CHECK(source_type IN ('memory', 'entity')),\n  \n  -- Target: can be memory or entity ID\n  target_id TEXT NOT NULL,\n  target_type TEXT NOT NULL CHECK(target_type IN ('memory', 'entity')),\n  \n  -- Relation type: 'related_to', 'mentions', 'depends_on', 'precedes', 'follows', etc.\n  relation TEXT NOT NULL DEFAULT 'related_to',\n  \n  -- Optional weight/strength (0.0 to 1.0)\n  weight REAL NOT NULL DEFAULT 1.0,\n  \n  -- Timestamps\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  \n  -- Prevent duplicate relations\n  UNIQUE(source_id, target_id, relation)\n);\n\n-- Indexes for relations\nCREATE INDEX IF NOT EXISTS idx_relations_source ON relations(source_id, source_type);\nCREATE INDEX IF NOT EXISTS idx_relations_target ON relations(target_id, target_type);\nCREATE INDEX IF NOT EXISTS idx_relations_type ON relations(relation);\n\n-- =============================================================================\n-- FILE_ASSOCIATIONS TABLE (D5: Store both paths)\n-- Links memories to file paths\n-- =============================================================================\nCREATE TABLE IF NOT EXISTS file_associations (\n  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),\n  \n  -- The memory this file is associated with\n  memory_id TEXT NOT NULL REFERENCES memories(id) ON DELETE CASCADE,\n  \n  -- File paths (D5: store both for resilience)\n  absolute_path TEXT NOT NULL,\n  relative_path TEXT,\n  \n  -- Optional: specific location within file\n  line_start INTEGER,\n  line_end INTEGER,\n  \n  -- File metadata at time of association\n  file_hash TEXT,\n  file_size INTEGER,\n  file_modified_at TEXT,\n  \n  -- Timestamps\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  \n  -- Prevent duplicate associations\n  UNIQUE(memory_id, absolute_path)\n);\n\n-- Indexes for file associations\nCREATE INDEX IF NOT EXISTS idx_file_assoc_memory ON file_associations(memory_id);\nCREATE INDEX IF NOT EXISTS idx_file_assoc_absolute ON file_associations(absolute_path);\nCREATE INDEX IF NOT EXISTS idx_file_assoc_relative ON file_associations(relative_path);\n\n-- =============================================================================\n-- BACKUPS TABLE (D14: Auto backup on SessionEnd)\n-- Track backup history\n-- =============================================================================\nCREATE TABLE IF NOT EXISTS backups (\n  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),\n  \n  -- Backup file path\n  path TEXT NOT NULL,\n  \n  -- Size in bytes\n  size_bytes INTEGER NOT NULL,\n  \n  -- Counts at time of backup\n  memory_count INTEGER NOT NULL DEFAULT 0,\n  entity_count INTEGER NOT NULL DEFAULT 0,\n  relation_count INTEGER NOT NULL DEFAULT 0,\n  \n  -- Timestamps\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- Keep only last 10 backups (D14)\nCREATE TRIGGER IF NOT EXISTS limit_backups AFTER INSERT ON backups BEGIN\n  DELETE FROM backups WHERE id IN (\n    SELECT id FROM backups ORDER BY created_at DESC LIMIT -1 OFFSET 10\n  );\nEND;\n";
/**
 * SQL to create vector search virtual table (requires sqlite-vec extension)
 */
export declare const VECTOR_TABLE_SQL = "\n-- Vector similarity search for embeddings\n-- Note: This requires the sqlite-vec extension to be loaded first\nCREATE VIRTUAL TABLE IF NOT EXISTS memories_vec USING vec0(\n  embedding float[384]\n);\n";
/**
 * SQL to drop all tables (for testing/reset)
 */
export declare const DROP_ALL_SQL = "\nDROP TABLE IF EXISTS backups;\nDROP TABLE IF EXISTS file_associations;\nDROP TABLE IF EXISTS relations;\nDROP TABLE IF EXISTS entities;\nDROP TRIGGER IF EXISTS memories_ai;\nDROP TRIGGER IF EXISTS memories_ad;\nDROP TRIGGER IF EXISTS memories_au;\nDROP TABLE IF EXISTS memories_fts;\nDROP TABLE IF EXISTS memories;\nDROP TABLE IF EXISTS memories_vec;\nDROP TABLE IF EXISTS schema_version;\n";
//# sourceMappingURL=schema.d.ts.map